package rest

import (
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"os"
	"regexp"
	"sort"
	"strconv"
	"strings"

	"github.com/julienschmidt/httprouter"
	"github.com/neuvector/neuvector/controller/access"
	"github.com/neuvector/neuvector/controller/api"
	"github.com/neuvector/neuvector/controller/common"
	"github.com/neuvector/neuvector/controller/kv"
	"github.com/neuvector/neuvector/controller/resource"
	"github.com/neuvector/neuvector/share"
	"github.com/neuvector/neuvector/share/cluster"
	"github.com/neuvector/neuvector/share/utils"
	log "github.com/sirupsen/logrus"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var reservedVulProfEntryNames utils.Set = utils.NewSet(api.VulnerabilityNameRecent, api.VulnerabilityNameRecentWithoutFix)

func handlerVulnerabilityProfileList(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
	log.WithFields(log.Fields{"URL": r.URL.String()}).Debug("")
	defer r.Body.Close()

	acc, login := getAccessControl(w, r, "")
	if acc == nil {
		return
	}

	var resp api.RESTVulnerabilityProfilesData
	resp.Profiles = cacher.GetAllVulnerabilityProfiles(acc)

	// Sort by name, keep 'default' at the top
	sort.Slice(resp.Profiles, func(i, j int) bool {
		if resp.Profiles[i].Name == share.DefaultVulnerabilityProfileName {
			return true
		}
		return resp.Profiles[i].Name < resp.Profiles[j].Name
	})

	log.WithFields(log.Fields{"entries": len(resp.Profiles)}).Debug("Response")
	restRespSuccess(w, r, &resp, acc, login, nil, "Get vulnerability profile list")
}

func handlerVulnerabilityProfileShow(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
	log.WithFields(log.Fields{"URL": r.URL.String()}).Debug()
	defer r.Body.Close()

	acc, login := getAccessControl(w, r, "")
	if acc == nil {
		return
	}

	name := ps.ByName("name")

	cp, err := cacher.GetVulnerabilityProfile(name, acc)
	if cp == nil {
		restRespNotFoundLogAccessDenied(w, login, err)
		return
	}

	resp := api.RESTVulnerabilityProfileData{Profile: cp}
	restRespSuccess(w, r, &resp, acc, login, nil, "Get vulnerability profile detail")
}

func checkVulnerabilityProfileEntry(e *api.RESTVulnerabilityProfileEntry) (*share.CLUSVulnerabilityProfileEntry, error) {
	ce := share.CLUSVulnerabilityProfileEntry{
		ID:      e.ID,
		Comment: e.Comment,
		Days:    e.Days,
		Domains: make([]string, 0),
		Images:  make([]string, 0),
	}

	if strings.HasPrefix(e.Name, "_") {
		if !reservedVulProfEntryNames.Contains(e.Name) {
			return nil, errors.New("Reserved entry name is invalid")
		}

		ce.Name = e.Name
		ce.NameFilter = e.Name
	} else if e.Name == "" {
		return nil, errors.New("Invalid vulnerability profile entry name")
	} else {
		s := strings.Replace(e.Name, "*", ".*", -1)
		// case insensitive
		if _, err := regexp.Compile("(?i)" + s); err != nil {
			log.WithFields(log.Fields{"entry": e.Name, "error": err}).Error("Invalid empty name")
			return nil, errors.New("Invalid vulnerability profile entry name")
		}

		ce.Name = e.Name
		ce.NameFilter = s
	}

	for _, d := range e.Domains {
		s := strings.Replace(d, "*", ".*", -1)
		if _, err := regexp.Compile(s); err != nil {
			log.WithFields(log.Fields{"domain": s, "error": err}).Error("Invalid empty namespace filter")
			return nil, fmt.Errorf("Invalid namespace filter: %s", d)
		}

		ce.Domains = append(ce.Domains, d)
	}

	for _, d := range e.Images {
		if d == "" {
			log.Error("Invalid empty image filter")
			return nil, fmt.Errorf("Invalid empty image filter")
		}
		if strings.HasPrefix(d, "https:") || strings.HasPrefix(d, "http:") {
			log.WithFields(log.Fields{"image": d}).Error("Invalid image filter")
			return nil, fmt.Errorf("Image filter with registry is not accepted: %s", d)
		}
		if colon := strings.LastIndex(d, ":"); colon != -1 {
			if slash := strings.LastIndex(d, "/"); slash != -1 && colon < slash {
				log.WithFields(log.Fields{"image": d}).Error("Invalid image filter")
				return nil, fmt.Errorf("Image filter with registry is not accepted: %s", d)
			}
			// if colon is the last char, append latest
			if colon == len(d)-1 {
				d = fmt.Sprintf("%slatest", d)
			}
		} else {
			// append latest if without tag
			d = fmt.Sprintf("%s:latest", d)
		}

		s := strings.Replace(d, "*", ".*", -1)
		if _, err := regexp.Compile(s); err != nil {
			log.WithFields(log.Fields{"image": d, "error": err}).Error("Invalid image filter")
			return nil, fmt.Errorf("Invalid image name: %s", d)
		}

		ce.Images = append(ce.Images, d)
	}

	return &ce, nil
}

func configVulnerabilityProfileEntry(cvp *share.CLUSVulnerabilityProfile, entries []*api.RESTVulnerabilityProfileEntry, create bool) error {
	ids := utils.NewSet()
	for _, ce := range cvp.Entries {
		ids.Add(ce.ID)
	}

	for _, re := range entries {
		ce, err := checkVulnerabilityProfileEntry(re)
		if err != nil {
			return err
		}

		if create {
			if re.ID == 0 {
				re.ID = getAvailableRuleID(ruleTypeVulProf, ids, cvp.CfgType)
				if re.ID == 0 {
					return errors.New("Failed to locate available entry ID")
				}

				ids.Add(re.ID)
			} else if ids.Contains(re.ID) {
				return errors.New("Duplicate entry ID")
			} else if re.ID < api.StartingLocalVulProfRuleID {
				return errors.New("Invalid entry ID")
			}

			ce.ID = re.ID
			cvp.Entries = append(cvp.Entries, ce)
		} else {
			if !ids.Contains(re.ID) {
				return errors.New("Failed to find entry ID")
			}

			for i, old := range cvp.Entries {
				if old.ID == re.ID {
					cvp.Entries[i] = ce
				}
			}
		}
	}

	return nil
}

func configVulnerabilityProfile(rvp *api.RESTVulnerabilityProfileConfig, option string, cfgType share.TCfgType,
	cvp *share.CLUSVulnerabilityProfile) (*share.CLUSVulnerabilityProfile, error) {

	var cvpEntries []*share.CLUSVulnerabilityProfileEntry

	if rvp.Entries != nil {
		ids := utils.NewSet()
		if option == "replace" {
			cvpEntries = make([]*share.CLUSVulnerabilityProfileEntry, 0, len(*rvp.Entries))
		} else if option == "merge" {
			// Matching of images/namespaces is like (match any image && match any namespace) in func(vpf vpFilter) filterOneVulTrait()
			// It means we should not merge the images/namespaces of 2 profile entrirs that have same cve name
			// For example:
			//   CVE-1000 / iperf1 / nv-1 : CVE-1000 for image iperf1 in namespace nv-1 is accepted
			//   CVE-1000 / iperf2 / nv-2 : CVE-1000 for image iperf2 in namespace nv-2 is accepted
			// If we merge them to:
			//   CVE-1000 / iperf1, iperf2 / nv-1, nv-2 : CVE-1000 for images (iperf1 or iperf2) in namespaces (nv-1 or nv-2) are accepted
			// The merged entry has different meaning than before merge.
			// So for "merge" option, we simply "append" the entries to the slice for cve-based entries.
			// "_RecentVuln" & "_RecentVulnWithoutFix" can have multiple entries as well.
			cvpEntries = make([]*share.CLUSVulnerabilityProfileEntry, 0, len(*rvp.Entries)+len(cvp.Entries))
			for _, ce := range cvp.Entries {
				cvpEntries = append(cvpEntries, ce)
				ids.Add(ce.ID)
			}
		}
		for _, re := range *rvp.Entries {
			ce, err := checkVulnerabilityProfileEntry(re)
			if err != nil {
				return nil, err
			}

			if re.ID == 0 {
				re.ID = getAvailableRuleID(ruleTypeVulProf, ids, cfgType)
				if re.ID == 0 {
					return nil, errors.New("Failed to locate available rule ID")
				}

				ids.Add(re.ID)
			}

			ce.ID = re.ID
			cvpEntries = append(cvpEntries, ce)
		}
	}

	cvp.Name = rvp.Name
	cvp.CfgType = cfgType
	cvp.Entries = cvpEntries

	return cvp, nil
}

func handlerVulnerabilityProfileConfig(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
	log.WithFields(log.Fields{"URL": r.URL.String()}).Debug("")
	defer r.Body.Close()

	acc, login := getAccessControl(w, r, "")
	if acc == nil {
		return
	}

	name := ps.ByName("name")
	if name != share.DefaultVulnerabilityProfileName {
		msg := "Only the default vulnerability profile is allowed"
		log.Error(msg)
		restRespErrorMessage(w, http.StatusBadRequest, api.RESTErrInvalidRequest, msg)
		return
	}

	if cp, err := cacher.GetVulnerabilityProfile(name, acc); cp == nil {
		restRespNotFoundLogAccessDenied(w, login, err)
		return
	} else if cp.CfgType == api.CfgTypeGround {
		restRespError(w, http.StatusBadRequest, api.RESTErrOpNotAllowed)
		return
	}

	// Read request
	body, _ := io.ReadAll(r.Body)

	var rconf api.RESTVulnerabilityProfileConfigData
	err := json.Unmarshal(body, &rconf)
	if err != nil || rconf.Config == nil {
		log.WithFields(log.Fields{"error": err}).Error("Request error")
		restRespError(w, http.StatusBadRequest, api.RESTErrInvalidRequest)
		return
	}

	rvp := rconf.Config

	if rvp.Name != name {
		e := "Profile name mismatch"
		log.WithFields(log.Fields{"profile": rvp.Name}).Error(e)
		restRespErrorMessage(w, http.StatusBadRequest, api.RESTErrInvalidRequest, e)
		return
	}

	var lock cluster.LockInterface
	if lock, err = lockClusKey(w, share.CLUSLockVulnKey); err != nil {
		return
	}
	defer clusHelper.ReleaseLock(lock)

	retry := 0
	for retry < retryClusterMax {
		cvp, rev, err := clusHelper.GetVulnerabilityProfile(name, acc)
		if cvp == nil {
			restRespNotFoundLogAccessDenied(w, login, err)
			return
		}

		// clean up current entries
		if cvp, err = configVulnerabilityProfile(rvp, "replace", cvp.CfgType, cvp); err != nil {
			log.WithFields(log.Fields{"error": err}).Error("Failed to configure vulnerability profile")
			restRespErrorMessage(w, http.StatusBadRequest, api.RESTErrInvalidRequest, err.Error())
			return
		}

		if !acc.Authorize(cvp, nil) {
			restRespAccessDenied(w, login)
			return
		}

		if err := clusHelper.PutVulnerabilityProfile(cvp, &rev); err != nil {
			log.WithFields(log.Fields{"error": err, "rev": rev}).Error("")
			retry++
		} else {
			break
		}
	}

	if retry >= retryClusterMax {
		restRespError(w, http.StatusInternalServerError, api.RESTErrFailWriteCluster)
		return
	}

	restRespSuccess(w, r, nil, acc, login, &rconf, fmt.Sprintf("Configure vulnerability profile '%v'", rvp.Name))
}

func handlerVulnerabilityProfileEntryCreate(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
	log.WithFields(log.Fields{"URL": r.URL.String()}).Debug()
	defer r.Body.Close()

	acc, login := getAccessControl(w, r, "")
	if acc == nil {
		return
	}

	name := ps.ByName("name")
	if name != share.DefaultVulnerabilityProfileName {
		msg := "Only the default vulnerability profile is allowed"
		log.Error(msg)
		restRespErrorMessage(w, http.StatusBadRequest, api.RESTErrInvalidRequest, msg)
		return
	}

	if cp, err := cacher.GetVulnerabilityProfile(name, acc); cp == nil {
		restRespNotFoundLogAccessDenied(w, login, err)
		return
	} else if cp.CfgType == api.CfgTypeGround {
		restRespError(w, http.StatusBadRequest, api.RESTErrOpNotAllowed)
		return
	}

	// Read request
	body, _ := io.ReadAll(r.Body)

	var rconf api.RESTVulnerabilityProfileEntryConfigData
	err := json.Unmarshal(body, &rconf)
	if err != nil || rconf.Config == nil {
		log.WithFields(log.Fields{"error": err}).Error("Request error")
		restRespError(w, http.StatusBadRequest, api.RESTErrInvalidRequest)
		return
	} else if id := int32(rconf.Config.ID); id < 0 {
		log.Error("Invalid vulnerability profile entry id")
		restRespErrorMessage(w, http.StatusBadRequest, api.RESTErrInvalidRequest, "Invalid vulnerability profile entry id")
		return
	}

	re := rconf.Config

	var lock cluster.LockInterface
	if lock, err = lockClusKey(w, share.CLUSLockVulnKey); err != nil {
		return
	}
	defer clusHelper.ReleaseLock(lock)

	retry := 0
	for retry < retryClusterMax {
		cvp, rev, err := clusHelper.GetVulnerabilityProfile(name, acc)
		if cvp == nil {
			restRespNotFoundLogAccessDenied(w, login, err)
			return
		}

		if err := configVulnerabilityProfileEntry(cvp, []*api.RESTVulnerabilityProfileEntry{re}, true); err != nil {
			log.WithFields(log.Fields{"name": name, "id": re.ID, "error": err}).Error("Failed to configure vulnerability profile entry")
			restRespErrorMessage(w, http.StatusBadRequest, api.RESTErrInvalidRequest, err.Error())
			return
		}

		if !acc.Authorize(cvp, nil) {
			restRespAccessDenied(w, login)
			return
		}

		if err := clusHelper.PutVulnerabilityProfile(cvp, &rev); err != nil {
			log.WithFields(log.Fields{"name": name, "error": err, "rev": rev}).Error("")
			retry++
		} else {
			break
		}
	}

	if retry >= retryClusterMax {
		restRespError(w, http.StatusInternalServerError, api.RESTErrFailWriteCluster)
		return
	}

	restRespSuccess(w, r, &rconf, acc, login, &rconf, fmt.Sprintf("Create vulnerability profile entry '%v'", re.ID))
}

func handlerVulnerabilityProfileEntryConfig(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
	log.WithFields(log.Fields{"URL": r.URL.String()}).Debug()
	defer r.Body.Close()

	acc, login := getAccessControl(w, r, "")
	if acc == nil {
		return
	}

	name := ps.ByName("name")
	if name != share.DefaultVulnerabilityProfileName {
		msg := "Only the default vulnerability profile is allowed"
		log.Error(msg)
		restRespErrorMessage(w, http.StatusBadRequest, api.RESTErrInvalidRequest, msg)
		return
	}

	idStr := ps.ByName("id")
	id, err := strconv.ParseInt(idStr, 10, 32)
	if err != nil || id <= 0 {
		log.Error("Invalid vulnerability profile entry id")
		restRespErrorMessage(w, http.StatusBadRequest, api.RESTErrInvalidRequest, "Invalid vulnerability profile entry id")
		return
	}

	if cp, err := cacher.GetVulnerabilityProfile(name, acc); cp == nil {
		restRespNotFoundLogAccessDenied(w, login, err)
		return
	} else if cp.CfgType == api.CfgTypeGround {
		restRespError(w, http.StatusBadRequest, api.RESTErrOpNotAllowed)
		return
	}

	// Read request
	body, _ := io.ReadAll(r.Body)

	var rconf api.RESTVulnerabilityProfileEntryConfigData
	err = json.Unmarshal(body, &rconf)
	if err != nil || rconf.Config == nil {
		log.WithFields(log.Fields{"error": err}).Error("Request error")
		restRespError(w, http.StatusBadRequest, api.RESTErrInvalidRequest)
		return
	}

	if uint32(id) != rconf.Config.ID {
		e := "Entry ID mismatch"
		log.WithFields(log.Fields{"name": name, "id": rconf.Config.ID}).Error(e)
		restRespErrorMessage(w, http.StatusBadRequest, api.RESTErrInvalidRequest, e)
		return
	}

	re := rconf.Config

	var lock cluster.LockInterface
	if lock, err = lockClusKey(w, share.CLUSLockVulnKey); err != nil {
		return
	}
	defer clusHelper.ReleaseLock(lock)

	retry := 0
	for retry < retryClusterMax {
		cvp, rev, err := clusHelper.GetVulnerabilityProfile(name, acc)
		if cvp == nil {
			restRespNotFoundLogAccessDenied(w, login, err)
			return
		}

		if err := configVulnerabilityProfileEntry(cvp, []*api.RESTVulnerabilityProfileEntry{re}, false); err != nil {
			log.WithFields(log.Fields{"name": name, "id": id, "error": err}).Error("Failed to configure vulnerability profile entry")
			restRespErrorMessage(w, http.StatusBadRequest, api.RESTErrInvalidRequest, err.Error())
			return
		}

		if !acc.Authorize(cvp, nil) {
			restRespAccessDenied(w, login)
			return
		}

		if err := clusHelper.PutVulnerabilityProfile(cvp, &rev); err != nil {
			log.WithFields(log.Fields{"name": name, "error": err, "rev": rev}).Error("")
			retry++
		} else {
			break
		}
	}

	if retry >= retryClusterMax {
		restRespError(w, http.StatusInternalServerError, api.RESTErrFailWriteCluster)
		return
	}

	restRespSuccess(w, r, nil, acc, login, &rconf, fmt.Sprintf("Configure vulnerability profile entry '%v'", re.ID))
}

func handlerVulnerabilityProfileEntryDelete(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
	log.WithFields(log.Fields{"URL": r.URL.String()}).Debug()
	defer r.Body.Close()

	acc, login := getAccessControl(w, r, "")
	if acc == nil {
		return
	}

	name := ps.ByName("name")
	if name != share.DefaultVulnerabilityProfileName {
		msg := "Only the default vulnerability profile is allowed"
		log.Error(msg)
		restRespErrorMessage(w, http.StatusBadRequest, api.RESTErrInvalidRequest, msg)
		return
	}

	idStr := ps.ByName("id")
	id, err := strconv.ParseInt(idStr, 10, 32)
	if err != nil || id <= 0 {
		log.Error("Invalid vulnerability profile entry id")
		restRespErrorMessage(w, http.StatusBadRequest, api.RESTErrInvalidRequest, "Invalid vulnerability profile entry id")
		return
	}

	if cp, err := cacher.GetVulnerabilityProfile(name, acc); cp == nil {
		restRespNotFoundLogAccessDenied(w, login, err)
		return
	} else if cp.CfgType == api.CfgTypeGround {
		restRespError(w, http.StatusBadRequest, api.RESTErrOpNotAllowed)
		return
	}

	var lock cluster.LockInterface
	if lock, err = lockClusKey(w, share.CLUSLockVulnKey); err != nil {
		return
	}
	defer clusHelper.ReleaseLock(lock)

	retry := 0
	for retry < retryClusterMax {
		cvp, rev, err := clusHelper.GetVulnerabilityProfile(name, acc)
		if cvp == nil {
			restRespNotFoundLogAccessDenied(w, login, err)
			return
		}

		var deled bool
		for i, ce := range cvp.Entries {
			if ce.ID == uint32(id) {
				copy(cvp.Entries[i:], cvp.Entries[i+1:])
				cvp.Entries[len(cvp.Entries)-1] = nil
				cvp.Entries = cvp.Entries[:len(cvp.Entries)-1]
				deled = true
				break
			}
		}

		if !deled {
			log.WithFields(log.Fields{"name": name, "id": id}).Error("Entry not found")
			restRespErrorMessage(w, http.StatusBadRequest, api.RESTErrInvalidRequest, "Unable to find specified entry")
			return
		}

		if !acc.Authorize(cvp, nil) {
			restRespAccessDenied(w, login)
			return
		}

		if err := clusHelper.PutVulnerabilityProfile(cvp, &rev); err != nil {
			log.WithFields(log.Fields{"name": name, "error": err, "rev": rev}).Error("")
			retry++
		} else {
			break
		}
	}

	if retry >= retryClusterMax {
		restRespError(w, http.StatusInternalServerError, api.RESTErrFailWriteCluster)
		return
	}

	restRespSuccess(w, r, nil, acc, login, nil, fmt.Sprintf("Delete vulnerability profile entry '%v'", id))
}

func handlerVulnProfileExport(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
	log.WithFields(log.Fields{"URL": r.URL.String()}).Debug()
	defer r.Body.Close()

	acc, login := getAccessControl(w, r, access.AccessOPRead)
	if acc == nil {
		return
	}

	if !acc.Authorize(&share.CLUSVulnerabilityProfile{}, nil) {
		restRespAccessDenied(w, login)
		return
	}

	var rconf api.RESTVulnProfilesExport
	body, _ := io.ReadAll(r.Body)
	err := json.Unmarshal(body, &rconf)
	if err == nil {
		for _, name := range rconf.Names {
			if name != share.DefaultVulnerabilityProfileName {
				err = errors.New("Non-default profile name is not supported yet")
				break
			}
		}
	}
	if err != nil {
		log.WithFields(log.Fields{"error": err}).Error("Request error")
		restRespErrorMessage(w, http.StatusBadRequest, api.RESTErrInvalidRequest, err.Error())
		return
	}
	if len(rconf.Names) == 0 {
		rconf.Names = []string{share.DefaultVulnerabilityProfileName}
	}

	apiVersion := fmt.Sprintf("%s/%s", common.OEMClusterSecurityRuleGroup, resource.NvVulnProfileSecurityRuleVersion)
	kind := resource.NvVulnProfileSecurityRuleKind
	resp := resource.NvVulnProfileSecurityRuleList{
		TypeMeta: metav1.TypeMeta{
			Kind:       resource.NvListKind,
			APIVersion: apiVersion,
		},
	}

	// export vulnerability profile (currently only default profile is supported)
	var lock cluster.LockInterface
	if lock, err = lockClusKey(w, share.CLUSLockVulnKey); err != nil {
		return
	}
	defer clusHelper.ReleaseLock(lock)

	vpNames := utils.NewSet()
	for _, name := range rconf.Names {
		if vpNames.Contains(name) {
			continue
		}
		profile, _, _ := clusHelper.GetVulnerabilityProfile(name, acc)
		if profile == nil {
			e := "vulnerability profile doesn't exist"
			log.WithFields(log.Fields{"name": name}).Error(e)
			restRespErrorMessage(w, http.StatusNotFound, api.RESTErrObjectNotFound, e)
			return
		}
		sort.Slice(profile.Entries, func(s, t int) bool {
			return profile.Entries[s].ID < profile.Entries[t].ID
		})

		ids := utils.NewSet()
		for _, vpe := range profile.Entries {
			ids.Add(vpe.ID)
		}
		entryList := make([]*resource.NvSecurityVulnProfileEntry, 0, ids.Cardinality())
		for _, entry := range profile.Entries {
			if ids.Contains(entry.ID) {
				entry := &resource.NvSecurityVulnProfileEntry{
					Name:    entry.Name,
					Comment: &entry.Comment,
					Days:    &entry.Days,
					Domains: entry.Domains,
					Images:  entry.Images,
				}
				entryList = append(entryList, entry)
			}
		}
		resptmp := resource.NvVulnProfileSecurityRule{
			TypeMeta: metav1.TypeMeta{
				APIVersion: apiVersion,
				Kind:       kind,
			},
			ObjectMeta: metav1.ObjectMeta{
				Name: name,
			},
			Spec: resource.NvSecurityVulnProfileSpec{
				Profile: &resource.NvSecurityVulnProfile{
					Entries: entryList,
				},
			},
		}
		resp.Items = append(resp.Items, resptmp)
		vpNames.Add(name)
	}

	doExport("cfgVulProfileExport.yaml", "vulnerability profile", rconf.RemoteExportOptions, resp, w, r, acc, login)
}

func handlerVulnProfileImport(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
	log.WithFields(log.Fields{"URL": r.URL.String()}).Debug()
	defer r.Body.Close()

	acc, login := getAccessControl(w, r, "")
	if acc == nil {
		return
	} else if cp, err := cacher.GetVulnerabilityProfile(share.DefaultVulnerabilityProfileName, acc); err != nil {
		restRespNotFoundLogAccessDenied(w, login, err)
		return
	} else if cp.CfgType == api.CfgTypeGround {
		restRespError(w, http.StatusBadRequest, api.RESTErrOpNotAllowed)
		return
	}

	tid := r.Header.Get("X-Transaction-ID")
	_importHandler(w, r, tid, share.IMPORT_TYPE_VULN_PROFILE, share.PREFIX_IMPORT_VULN_PROFILE, acc, login)
}

func importVulnProfile(scope, option string, loginDomainRoles access.DomainRole, importTask share.CLUSImportTask, postImportOp kv.PostImportFunc) error {
	log.Debug()
	defer os.Remove(importTask.TempFilename)

	json_data, _ := os.ReadFile(importTask.TempFilename)
	var secRuleList resource.NvVulnProfileSecurityRuleList
	var secRule resource.NvVulnProfileSecurityRule
	var secRules []resource.NvVulnProfileSecurityRule
	var invalidCrdKind bool
	var err error
	if err = json.Unmarshal(json_data, &secRuleList); err != nil || len(secRuleList.Items) == 0 {
		if err = json.Unmarshal(json_data, &secRule); err == nil {
			secRules = append(secRules, secRule)
		}
	} else {
		secRules = secRuleList.Items
	}
	for _, r := range secRules {
		if r.APIVersion != "neuvector.com/v1" || r.Kind != resource.NvVulnProfileSecurityRuleKind {
			invalidCrdKind = true
			break
		}
	}
	if invalidCrdKind || len(secRules) == 0 {
		msg := "Invalid security rule(s)"
		log.WithFields(log.Fields{"error": err}).Error(msg)
		postImportOp(fmt.Errorf("%s", msg), importTask, loginDomainRoles, "", share.IMPORT_TYPE_VULN_PROFILE)
		return nil
	}

	var inc float32
	var progress float32 // progress percentage

	inc = 90.0 / float32(2+2*len(secRules))
	vulProfilesCfg := make([]*resource.NvSecurityParse, 0, len(secRules))
	progress = 6

	importTask.Percentage = int(progress)
	importTask.Status = share.IMPORT_RUNNING
	clusHelper.PutImportTask(&importTask)

	var crdHandler nvCrdHandler
	crdHandler.Init(share.CLUSLockVulnKey)
	if crdHandler.AcquireLock(clusterLockWait) {
		defer crdHandler.ReleaseLock()

		// [1]: parse all security rules in the yaml file
		for _, secRule := range secRules {
			if vpCfgRet, errCount, errMsg, _ := crdHandler.parseCurCrdVulnProfileContent(&secRule, share.ReviewTypeImportVulnProfile, share.ReviewTypeDisplayVulnProfile); errCount > 0 {
				err = fmt.Errorf("%s", errMsg)
				break
			} else {
				vulProfilesCfg = append(vulProfilesCfg, vpCfgRet)
				progress += inc
				importTask.Percentage = int(progress)
				clusHelper.PutImportTask(&importTask)
			}
		}

		progress += inc
		importTask.Percentage = int(progress)
		clusHelper.PutImportTask(&importTask)

		if err == nil {
			// [2]: import vulnerability profile defined in the yaml file
			for _, parsedCfg := range vulProfilesCfg {
				// [3] import vulnerability profile defined in the yaml file
				if err = crdHandler.crdHandleVulnProfile(parsedCfg.VulnProfileCfg, option, nil, share.ReviewTypeImportVulnProfile); err != nil {
					break
				}
				progress += inc
				importTask.Percentage = int(progress)
				clusHelper.PutImportTask(&importTask)
			}
		}
		importTask.Percentage = 90
		clusHelper.PutImportTask(&importTask)
	}

	postImportOp(err, importTask, loginDomainRoles, "", share.IMPORT_TYPE_VULN_PROFILE)

	return nil
}
