package rest

import (
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"net/http"
	"os"
	"regexp"
	"sort"
	"strconv"
	"strings"

	"github.com/julienschmidt/httprouter"
	cmetav1 "github.com/neuvector/k8s/apis/meta/v1"
	"github.com/neuvector/neuvector/controller/access"
	"github.com/neuvector/neuvector/controller/api"
	"github.com/neuvector/neuvector/controller/common"
	"github.com/neuvector/neuvector/controller/kv"
	"github.com/neuvector/neuvector/controller/resource"
	"github.com/neuvector/neuvector/share"
	"github.com/neuvector/neuvector/share/cluster"
	"github.com/neuvector/neuvector/share/utils"
	log "github.com/sirupsen/logrus"
	"sigs.k8s.io/yaml"
)

var reservedVulProfEntryNames utils.Set = utils.NewSet(api.VulnerabilityNameRecent, api.VulnerabilityNameRecentWithoutFix)

func handlerVulnerabilityProfileList(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
	log.WithFields(log.Fields{"URL": r.URL.String()}).Debug()
	defer r.Body.Close()

	acc, login := getAccessControl(w, r, "")
	if acc == nil {
		return
	}

	var resp api.RESTVulnerabilityProfilesData
	resp.Settings, resp.Profiles = cacher.GetAllVulnerabilityProfiles(acc)

	// Sort by name, keep 'default' at the top
	sort.Slice(resp.Profiles, func(i, j int) bool {
		if resp.Profiles[i].Name == share.DefaultVulnerabilityProfileName {
			return true
		}
		return resp.Profiles[i].Name < resp.Profiles[j].Name
	})

	log.WithFields(log.Fields{"entries": len(resp.Profiles)}).Debug("Response")
	restRespSuccess(w, r, &resp, acc, login, nil, "Get vulnerability profile list")
}

func handlerVulnerabilityProfileShow(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
	log.WithFields(log.Fields{"URL": r.URL.String()}).Debug()
	defer r.Body.Close()

	acc, login := getAccessControl(w, r, "")
	if acc == nil {
		return
	}

	name := ps.ByName("name")

	cp, err := cacher.GetVulnerabilityProfile(name, acc)
	if cp == nil {
		restRespNotFoundLogAccessDenied(w, login, err)
		return
	}

	resp := api.RESTVulnerabilityProfileData{Profile: cp}
	restRespSuccess(w, r, &resp, acc, login, nil, "Get vulnerability profile detail")
}

func checkVulnerabilityProfileEntry(e *api.RESTVulnerabilityProfileEntry) (*share.CLUSVulnerabilityProfileEntry, error) {
	ce := share.CLUSVulnerabilityProfileEntry{
		ID:      e.ID,
		Comment: e.Comment,
		Days:    e.Days,
		Domains: make([]string, 0),
		Images:  make([]string, 0),
	}

	if strings.HasPrefix(e.Name, "_") {
		if !reservedVulProfEntryNames.Contains(e.Name) {
			return nil, errors.New("Reserved entry name is invalid")
		}

		ce.Name = e.Name
		ce.NameFilter = e.Name
	} else if e.Name == "" {
		return nil, errors.New("Invalid vulnerability profile entry name")
	} else {
		s := strings.Replace(e.Name, "*", ".*", -1)
		// case insensitive
		if _, err := regexp.Compile("(?i)" + s); err != nil {
			log.WithFields(log.Fields{"entry": e.Name, "error": err}).Error("Invalid empty name")
			return nil, errors.New("Invalid vulnerability profile entry name")
		}

		ce.Name = e.Name
		ce.NameFilter = s
	}

	for _, d := range e.Domains {
		s := strings.Replace(d, "*", ".*", -1)
		if _, err := regexp.Compile(s); err != nil {
			log.WithFields(log.Fields{"domain": s, "error": err}).Error("Invalid empty namespace filter")
			return nil, fmt.Errorf("Invalid namespace filter: %s", d)
		}

		ce.Domains = append(ce.Domains, d)
	}

	for _, d := range e.Images {
		if d == "" {
			log.Error("Invalid empty image filter")
			return nil, fmt.Errorf("Invalid empty image filter")
		}
		if strings.HasPrefix(d, "https:") || strings.HasPrefix(d, "http:") {
			log.WithFields(log.Fields{"image": d}).Error("Invalid image filter")
			return nil, fmt.Errorf("Image filter with registry is not accepted: %s", d)
		}
		if colon := strings.LastIndex(d, ":"); colon != -1 {
			if slash := strings.LastIndex(d, "/"); slash != -1 && colon < slash {
				log.WithFields(log.Fields{"image": d}).Error("Invalid image filter")
				return nil, fmt.Errorf("Image filter with registry is not accepted: %s", d)
			}
			// if colon is the last char, append latest
			if colon == len(d)-1 {
				d = fmt.Sprintf("%slatest", d)
			}
		} else {
			// append latest if without tag
			d = fmt.Sprintf("%s:latest", d)
		}

		s := strings.Replace(d, "*", ".*", -1)
		if _, err := regexp.Compile(s); err != nil {
			log.WithFields(log.Fields{"image": d, "error": err}).Error("Invalid image filter")
			return nil, fmt.Errorf("Invalid image name: %s", d)
		}

		ce.Images = append(ce.Images, d)
	}

	return &ce, nil
}

func configVulnerabilityProfileEntry(cvp *share.CLUSVulnerabilityProfile, entries []*api.RESTVulnerabilityProfileEntry, create bool) error {
	ids := utils.NewSet()
	for _, ce := range cvp.Entries {
		ids.Add(ce.ID)
	}

	for _, re := range entries {
		ce, err := checkVulnerabilityProfileEntry(re)
		if err != nil {
			return err
		}

		if create {
			if re.ID == 0 {
				re.ID = getAvailableRuleID(ruleTypeVulProf, ids, cvp.CfgType)
				if re.ID == 0 {
					return errors.New("Failed to locate available entry ID")
				}

				ids.Add(re.ID)
			} else if ids.Contains(re.ID) {
				return errors.New("Duplicate entry ID")
			} else if re.ID < api.StartingLocalVulProfRuleID {
				return errors.New("Invalid entry ID")
			}

			ce.ID = re.ID
			cvp.Entries = append(cvp.Entries, ce)
		} else {
			if !ids.Contains(re.ID) {
				return errors.New("Failed to find entry ID")
			}

			for i, old := range cvp.Entries {
				if old.ID == re.ID {
					cvp.Entries[i] = ce
				}
			}
		}
	}

	return nil
}

func configVulnerabilityProfile(rvp *api.RESTVulnerabilityProfileConfig, cfgType share.TCfgType, cvp *share.CLUSVulnerabilityProfile) (*share.CLUSVulnerabilityProfile, error) {
	var cvpEntries []*share.CLUSVulnerabilityProfileEntry

	if rvp.Entries != nil {
		cvpEntries = make([]*share.CLUSVulnerabilityProfileEntry, 0, len(*rvp.Entries))

		if len(*rvp.Entries) > 0 {
			sort.SliceStable(*rvp.Entries, func(i, j int) bool {
				return (*rvp.Entries)[i].Name < (*rvp.Entries)[j].Name
			})
		}

		ids := utils.NewSet()
		for _, re := range *rvp.Entries {
			if ids.Contains(re.ID) {
				return nil, errors.New("Duplicate entry ID")
			}
			if re.ID != 0 {
				ids.Add(re.ID)
			}
		}
		for _, re := range *rvp.Entries {
			ce, err := checkVulnerabilityProfileEntry(re)
			if err != nil {
				return nil, err
			}

			if re.ID == 0 {
				re.ID = getAvailableRuleID(ruleTypeVulProf, ids, cfgType)
				if re.ID == 0 {
					return nil, errors.New("Failed to locate available rule ID")
				}

				ids.Add(re.ID)
			}

			ce.ID = re.ID
			cvpEntries = append(cvpEntries, ce)
		}
	}

	cvp.Name = rvp.Name
	cvp.CfgType = cfgType
	cvp.Entries = cvpEntries

	return cvp, nil
}

func handlerVulnerabilityProfileConfig(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
	log.WithFields(log.Fields{"URL": r.URL.String()}).Debug()
	defer r.Body.Close()

	acc, login := getAccessControl(w, r, "")
	if acc == nil {
		return
	}

	name := ps.ByName("name")
	if name != share.DefaultVulnerabilityProfileName {
		msg := "Only the default vulnerability profile is allowed"
		log.Error(msg)
		restRespErrorMessage(w, http.StatusBadRequest, api.RESTErrInvalidRequest, msg)
		return
	}

	if cp, err := cacher.GetVulnerabilityProfile(name, acc); cp == nil {
		restRespNotFoundLogAccessDenied(w, login, err)
		return
	} else if cp.CfgType == api.CfgTypeGround {
		restRespError(w, http.StatusBadRequest, api.RESTErrOpNotAllowed)
		return
	}

	// Read request
	body, _ := ioutil.ReadAll(r.Body)

	var rconf api.RESTVulnerabilityProfileConfigData
	err := json.Unmarshal(body, &rconf)
	if err != nil || rconf.Config == nil {
		log.WithFields(log.Fields{"error": err}).Error("Request error")
		restRespError(w, http.StatusBadRequest, api.RESTErrInvalidRequest)
		return
	}

	rvp := rconf.Config

	if rvp.Name != name {
		e := "Profile name mismatch"
		log.WithFields(log.Fields{"profile": rvp.Name}).Error(e)
		restRespErrorMessage(w, http.StatusBadRequest, api.RESTErrInvalidRequest, e)
		return
	}

	var lock cluster.LockInterface
	if lock, err = lockClusKey(w, share.CLUSLockVulKey); err != nil {
		return
	}
	defer clusHelper.ReleaseLock(lock)

	retry := 0
	for retry < retryClusterMax {
		cvp, rev, err := clusHelper.GetVulnerabilityProfile(name, acc)
		if cvp == nil {
			restRespNotFoundLogAccessDenied(w, login, err)
			return
		}

		// clean up current entries
		if cvp, err = configVulnerabilityProfile(rvp, cvp.CfgType, cvp); err != nil {
			log.WithFields(log.Fields{"error": err}).Error("Failed to configure vulnerability profile")
			restRespErrorMessage(w, http.StatusBadRequest, api.RESTErrInvalidRequest, err.Error())
			return
		}

		if !acc.Authorize(cvp, nil) {
			restRespAccessDenied(w, login)
			return
		}

		if err := clusHelper.PutVulnerabilityProfile(cvp, &rev); err != nil {
			log.WithFields(log.Fields{"error": err, "rev": rev}).Error("")
			retry++
		} else {
			break
		}
	}

	if retry >= retryClusterMax {
		restRespError(w, http.StatusInternalServerError, api.RESTErrFailWriteCluster)
		return
	}

	restRespSuccess(w, r, nil, acc, login, &rconf, fmt.Sprintf("Configure vulnerability profile '%v'", rvp.Name))
}

func handlerVulnerabilityProfileEntryCreate(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
	log.WithFields(log.Fields{"URL": r.URL.String()}).Debug()
	defer r.Body.Close()

	acc, login := getAccessControl(w, r, "")
	if acc == nil {
		return
	}

	name := ps.ByName("name")
	if name != share.DefaultVulnerabilityProfileName {
		msg := "Only the default vulnerability profile is allowed"
		log.Error(msg)
		restRespErrorMessage(w, http.StatusBadRequest, api.RESTErrInvalidRequest, msg)
		return
	}

	if cp, err := cacher.GetVulnerabilityProfile(name, acc); cp == nil {
		restRespNotFoundLogAccessDenied(w, login, err)
		return
	} else if cp.CfgType == api.CfgTypeGround {
		restRespError(w, http.StatusBadRequest, api.RESTErrOpNotAllowed)
		return
	}

	// Read request
	body, _ := ioutil.ReadAll(r.Body)

	var rconf api.RESTVulnerabilityProfileEntryConfigData
	err := json.Unmarshal(body, &rconf)
	if err != nil || rconf.Config == nil {
		log.WithFields(log.Fields{"error": err}).Error("Request error")
		restRespError(w, http.StatusBadRequest, api.RESTErrInvalidRequest)
		return
	} else if id := int32(rconf.Config.ID); id < 0 {
		log.Error("Invalid vulnerability profile entry id")
		restRespErrorMessage(w, http.StatusBadRequest, api.RESTErrInvalidRequest, "Invalid vulnerability profile entry id")
		return
	}

	re := rconf.Config

	var lock cluster.LockInterface
	if lock, err = lockClusKey(w, share.CLUSLockVulKey); err != nil {
		return
	}
	defer clusHelper.ReleaseLock(lock)

	retry := 0
	for retry < retryClusterMax {
		cvp, rev, err := clusHelper.GetVulnerabilityProfile(name, acc)
		if cvp == nil {
			restRespNotFoundLogAccessDenied(w, login, err)
			return
		}

		if err := configVulnerabilityProfileEntry(cvp, []*api.RESTVulnerabilityProfileEntry{re}, true); err != nil {
			log.WithFields(log.Fields{"name": name, "id": re.ID, "error": err}).Error("Failed to configure vulnerability profile entry")
			restRespErrorMessage(w, http.StatusBadRequest, api.RESTErrInvalidRequest, err.Error())
			return
		}

		if !acc.Authorize(cvp, nil) {
			restRespAccessDenied(w, login)
			return
		}

		if err := clusHelper.PutVulnerabilityProfile(cvp, &rev); err != nil {
			log.WithFields(log.Fields{"name": name, "error": err, "rev": rev}).Error("")
			retry++
		} else {
			break
		}
	}

	if retry >= retryClusterMax {
		restRespError(w, http.StatusInternalServerError, api.RESTErrFailWriteCluster)
		return
	}

	restRespSuccess(w, r, nil, acc, login, &rconf, fmt.Sprintf("Create vulnerability profile entry '%v'", re.ID))
}

func handlerVulnerabilityProfileEntryConfig(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
	log.WithFields(log.Fields{"URL": r.URL.String()}).Debug()
	defer r.Body.Close()

	acc, login := getAccessControl(w, r, "")
	if acc == nil {
		return
	}

	name := ps.ByName("name")
	if name != share.DefaultVulnerabilityProfileName {
		msg := "Only the default vulnerability profile is allowed"
		log.Error(msg)
		restRespErrorMessage(w, http.StatusBadRequest, api.RESTErrInvalidRequest, msg)
		return
	}

	idStr := ps.ByName("id")
	id, err := strconv.ParseInt(idStr, 10, 32)
	if err != nil || id <= 0 {
		log.Error("Invalid vulnerability profile entry id")
		restRespErrorMessage(w, http.StatusBadRequest, api.RESTErrInvalidRequest, "Invalid vulnerability profile entry id")
		return
	}

	if cp, err := cacher.GetVulnerabilityProfile(name, acc); cp == nil {
		restRespNotFoundLogAccessDenied(w, login, err)
		return
	} else if cp.CfgType == api.CfgTypeGround {
		restRespError(w, http.StatusBadRequest, api.RESTErrOpNotAllowed)
		return
	}

	// Read request
	body, _ := ioutil.ReadAll(r.Body)

	var rconf api.RESTVulnerabilityProfileEntryConfigData
	err = json.Unmarshal(body, &rconf)
	if err != nil || rconf.Config == nil {
		log.WithFields(log.Fields{"error": err}).Error("Request error")
		restRespError(w, http.StatusBadRequest, api.RESTErrInvalidRequest)
		return
	}

	if uint32(id) != rconf.Config.ID {
		e := "Entry ID mismatch"
		log.WithFields(log.Fields{"name": name, "id": rconf.Config.ID}).Error(e)
		restRespErrorMessage(w, http.StatusBadRequest, api.RESTErrInvalidRequest, e)
		return
	}

	re := rconf.Config

	var lock cluster.LockInterface
	if lock, err = lockClusKey(w, share.CLUSLockVulKey); err != nil {
		return
	}
	defer clusHelper.ReleaseLock(lock)

	retry := 0
	for retry < retryClusterMax {
		cvp, rev, err := clusHelper.GetVulnerabilityProfile(name, acc)
		if cvp == nil {
			restRespNotFoundLogAccessDenied(w, login, err)
			return
		}

		if err := configVulnerabilityProfileEntry(cvp, []*api.RESTVulnerabilityProfileEntry{re}, false); err != nil {
			log.WithFields(log.Fields{"name": name, "id": id, "error": err}).Error("Failed to configure vulnerability profile entry")
			restRespErrorMessage(w, http.StatusBadRequest, api.RESTErrInvalidRequest, err.Error())
			return
		}

		if !acc.Authorize(cvp, nil) {
			restRespAccessDenied(w, login)
			return
		}

		if err := clusHelper.PutVulnerabilityProfile(cvp, &rev); err != nil {
			log.WithFields(log.Fields{"name": name, "error": err, "rev": rev}).Error()
			retry++
		} else {
			break
		}
	}

	if retry >= retryClusterMax {
		restRespError(w, http.StatusInternalServerError, api.RESTErrFailWriteCluster)
		return
	}

	restRespSuccess(w, r, nil, acc, login, &rconf, fmt.Sprintf("Configure vulnerability profile entry '%v'", re.ID))
}

func handlerVulnerabilityProfileEntryDelete(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
	log.WithFields(log.Fields{"URL": r.URL.String()}).Debug()
	defer r.Body.Close()

	acc, login := getAccessControl(w, r, "")
	if acc == nil {
		return
	}

	name := ps.ByName("name")
	if name != share.DefaultVulnerabilityProfileName {
		msg := "Only the default vulnerability profile is allowed"
		log.Error(msg)
		restRespErrorMessage(w, http.StatusBadRequest, api.RESTErrInvalidRequest, msg)
		return
	}

	idStr := ps.ByName("id")
	id, err := strconv.ParseInt(idStr, 10, 32)
	if err != nil || id <= 0 {
		log.Error("Invalid vulnerability profile entry id")
		restRespErrorMessage(w, http.StatusBadRequest, api.RESTErrInvalidRequest, "Invalid vulnerability profile entry id")
		return
	}

	if cp, err := cacher.GetVulnerabilityProfile(name, acc); cp == nil {
		restRespNotFoundLogAccessDenied(w, login, err)
		return
	} else if cp.CfgType == api.CfgTypeGround {
		restRespError(w, http.StatusBadRequest, api.RESTErrOpNotAllowed)
		return
	}

	var lock cluster.LockInterface
	if lock, err = lockClusKey(w, share.CLUSLockVulKey); err != nil {
		return
	}
	defer clusHelper.ReleaseLock(lock)

	retry := 0
	for retry < retryClusterMax {
		cvp, rev, err := clusHelper.GetVulnerabilityProfile(name, acc)
		if cvp == nil {
			restRespNotFoundLogAccessDenied(w, login, err)
			return
		}

		var deled bool
		for i, ce := range cvp.Entries {
			if ce.ID == uint32(id) {
				copy(cvp.Entries[i:], cvp.Entries[i+1:])
				cvp.Entries[len(cvp.Entries)-1] = nil
				cvp.Entries = cvp.Entries[:len(cvp.Entries)-1]
				deled = true
				break
			}
		}

		if !deled {
			log.WithFields(log.Fields{"name": name, "id": id}).Error("Entry not found")
			restRespErrorMessage(w, http.StatusBadRequest, api.RESTErrInvalidRequest, "Unable to find specified entry")
			return
		}

		if !acc.Authorize(cvp, nil) {
			restRespAccessDenied(w, login)
			return
		}

		if err := clusHelper.PutVulnerabilityProfile(cvp, &rev); err != nil {
			log.WithFields(log.Fields{"name": name, "error": err, "rev": rev}).Error("")
			retry++
		} else {
			break
		}
	}

	if retry >= retryClusterMax {
		restRespError(w, http.StatusInternalServerError, api.RESTErrFailWriteCluster)
		return
	}

	restRespSuccess(w, r, nil, acc, login, nil, fmt.Sprintf("Delete vulnerability profile entry '%v'", id))
}

func handlerVulProfileExport(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
	log.WithFields(log.Fields{"URL": r.URL.String()}).Debug()
	defer r.Body.Close()

	acc, login := getAccessControl(w, r, access.AccessOPRead)
	if acc == nil {
		return
	}

	if !acc.Authorize(&share.CLUSVulnerabilityProfile{}, nil) {
		restRespAccessDenied(w, login)
		return
	}

	var rconf api.RESTVulProfilesExport
	body, _ := ioutil.ReadAll(r.Body)
	err := json.Unmarshal(body, &rconf)
	if err == nil {
		for _, name := range rconf.Profiles {
			if name != share.DefaultVulnerabilityProfileName {
				err = errors.New("Non-default profile name is not supported yet")
				break
			}
		}
	}
	if err != nil {
		log.WithFields(log.Fields{"error": err}).Error("Request error")
		restRespErrorMessage(w, http.StatusBadRequest, api.RESTErrInvalidRequest, err.Error())
		return
	}
	if len(rconf.Profiles) == 0 {
		rconf.Profiles = []string{share.DefaultVulnerabilityProfileName}
	}

	apiVersion := fmt.Sprintf("%s/%s", common.OEMClusterSecurityRuleGroup, resource.NvVulProfileSecurityRuleVersion)
	kind := resource.NvVulProfileSecurityRuleKind
	resp := resource.NvVulProfileSecurityRuleList{
		Kind:       &resource.NvListKind,
		ApiVersion: &apiVersion,
	}

	// export vulnerability profile (currently only default profile is supported)
	var lock cluster.LockInterface
	if lock, err = lockClusKey(w, share.CLUSLockVulKey); err != nil {
		return
	}
	defer clusHelper.ReleaseLock(lock)

	vpNames := utils.NewSet()
	for _, name := range rconf.Profiles {
		if vpNames.Contains(name) {
			continue
		}
		profile, _, _ := clusHelper.GetVulnerabilityProfile(name, acc)
		if profile == nil {
			e := "vulnerability profile doesn't exist"
			log.WithFields(log.Fields{"name": name}).Error(e)
			restRespErrorMessage(w, http.StatusNotFound, api.RESTErrObjectNotFound, e)
			return
		}

		ids := utils.NewSet()
		for _, vpe := range profile.Entries {
			ids.Add(vpe.ID)
		}
		entryList := make([]*resource.NvSecurityVulProfileEntry, 0, ids.Cardinality())
		for _, entry := range profile.Entries {
			if ids.Contains(entry.ID) {
				entry := &resource.NvSecurityVulProfileEntry{
					Name:    entry.Name,
					Comment: &entry.Comment,
					Days:    &entry.Days,
					Domains: entry.Domains,
					Images:  entry.Images,
				}
				entryList = append(entryList, entry)
			}
		}
		resptmp := resource.NvVulProfileSecurityRule{
			ApiVersion: &apiVersion,
			Kind:       &kind,
			Metadata: &cmetav1.ObjectMeta{
				Name: &name,
			},
			Spec: resource.NvSecurityVulProfileSpec{
				Profile: &resource.NvSecurityVulProfile{
					Name:    name,
					Entries: entryList,
				},
			},
		}
		resp.Items = append(resp.Items, &resptmp)
		vpNames.Add(name)
	}

	// tell the browser the returned content should be downloaded
	var data []byte
	filename := "cfgVulProfileExport.yaml"
	w.Header().Set("Content-Disposition", "Attachment; filename="+filename)
	w.Header().Set("Content-Encoding", "gzip")
	w.WriteHeader(http.StatusOK)
	json_data, _ := json.MarshalIndent(resp, "", "  ")
	data, _ = yaml.JSONToYAML(json_data)
	data = utils.GzipBytes(data)
	w.Write(data)
}

func handlerVulProfileImport(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
	log.WithFields(log.Fields{"URL": r.URL.String()}).Debug()
	defer r.Body.Close()

	acc, login := getAccessControl(w, r, "")
	if acc == nil {
		return
	} else if cp, err := cacher.GetVulnerabilityProfile(share.DefaultVulnerabilityProfileName, acc); err != nil {
		restRespNotFoundLogAccessDenied(w, login, err)
		return
	} else if cp.CfgType == api.CfgTypeGround {
		restRespError(w, http.StatusBadRequest, api.RESTErrOpNotAllowed)
		return
	}

	tid := r.Header.Get("X-Transaction-ID")
	_importHandler(w, r, tid, share.IMPORT_TYPE_VUL_PROFILE, share.PREFIX_IMPORT_VUL_PROFILE, acc, login)
}

func importVulProfile(scope string, loginDomainRoles access.DomainRole, importTask share.CLUSImportTask, postImportOp kv.PostImportFunc) error {
	log.Debug()
	defer os.Remove(importTask.TempFilename)

	json_data, _ := ioutil.ReadFile(importTask.TempFilename)
	var secRuleList resource.NvVulProfileSecurityRuleList
	var secRule resource.NvVulProfileSecurityRule
	var secRules []*resource.NvVulProfileSecurityRule = []*resource.NvVulProfileSecurityRule{nil}
	var invalidCrdKind bool
	var err error
	if err = json.Unmarshal(json_data, &secRuleList); err != nil || len(secRuleList.Items) == 0 {
		if err = json.Unmarshal(json_data, &secRule); err == nil {
			secRules[0] = &secRule
		}
	} else {
		secRules = secRuleList.Items
	}
	for _, r := range secRules {
		if r.Kind == nil || (*r.Kind != resource.NvVulProfileSecurityRuleKind && *r.Kind != resource.NvVulProfileSecurityRuleListKind) {
			invalidCrdKind = true
			break
		}
	}
	if invalidCrdKind || len(secRules) == 0 {
		msg := "Invalid security rule(s)"
		log.WithFields(log.Fields{"error": err}).Error(msg)
		postImportOp(fmt.Errorf(msg), importTask, loginDomainRoles, "", share.IMPORT_TYPE_VUL_PROFILE)
		return nil
	}

	var inc float32
	var progress float32 // progress percentage

	inc = 90.0 / float32(2+2*len(secRules))
	vulProfilesCfg := make([]*resource.NvSecurityParse, 0, len(secRules))
	progress = 6

	importTask.Percentage = int(progress)
	importTask.Status = share.IMPORT_RUNNING
	clusHelper.PutImportTask(&importTask)

	var crdHandler nvCrdHandler
	crdHandler.Init(share.CLUSLockVulKey)
	if crdHandler.AcquireLock(clusterLockWait) {
		defer crdHandler.ReleaseLock()

		// [1]: parse all security rules in the yaml file
		for _, secRule := range secRules {
			if secRule == nil || secRule.Kind == nil || secRule.ApiVersion == nil {
				continue
			}
			if vpCfgRet, errCount, errMsg, _ := crdHandler.parseCurCrdVulProfileContent(secRule, share.ReviewTypeImportVulProfile, share.ReviewTypeDisplayVulProfile); errCount > 0 {
				err = fmt.Errorf(errMsg)
				break
			} else {
				log.WithFields(log.Fields{"target": vpCfgRet.TargetName}).Debug()
				vulProfilesCfg = append(vulProfilesCfg, vpCfgRet)
				progress += inc
				importTask.Percentage = int(progress)
				clusHelper.PutImportTask(&importTask)
			}
		}

		progress += inc
		importTask.Percentage = int(progress)
		clusHelper.PutImportTask(&importTask)

		if err == nil {
			// [2]: import vulnerability profile defined in the yaml file
			for _, parsedCfg := range vulProfilesCfg {
				// [3] import vulnerability profile defined in the yaml file
				if err = crdHandler.crdHandleVulProfile(parsedCfg.VulProfileCfg, nil, share.ReviewTypeImportVulProfile); err != nil {
					break
				}
				progress += inc
				importTask.Percentage = int(progress)
				clusHelper.PutImportTask(&importTask)
			}
		}
		importTask.Percentage = 90
		clusHelper.PutImportTask(&importTask)
	}

	postImportOp(err, importTask, loginDomainRoles, "", share.IMPORT_TYPE_VUL_PROFILE)

	return nil
}
