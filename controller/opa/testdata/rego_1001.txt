package neuvector_policy_1001

specification = spec {
	spec:={
		"version": "v1",
		"description": "NeuVector generated"
	}
}


violation[result]{
	request := _get_input("get")

	criteria_0(request)    # check [item.spec.initContainers[_].lifecycle.postStart.tcpSocket.host] with [containsAll]
	criteria_1(request)    # check [item.spec.containers[_].image] with [containsAny]

	result:={
		"message": "all criteria have been met"
	}
}

criteria_0(request)
{
	# custom criteria name = customPath
	# op = containsAll
	# value = localhost
	# valueType = string
	# path(orig) = item.spec.initContainers[_].lifecycle.postStart.tcpSocket.host

	user_provided_data := ["^localhost$"]

	# parameter path = request.spec.initContainers[_].lifecycle.postStart.tcpSocket.host
	image := request.spec.initContainers[i].image
	not inSidecarContainerList(image)

	value = request.spec.initContainers[i].lifecycle.postStart.tcpSocket.host
	operator_contains_all(user_provided_data, value)
}

criteria_1(request)
{
	# custom criteria name = customPath
	# op = containsAny
	# value = redis:latest,nginx:latest,sbomscanner
	# valueType = string
	# path(orig) = item.spec.containers[_].image

	user_provided_data := ["^redis:latest$","^nginx:latest$","^sbomscanner$"]

	# parameter path = request.spec.containers[_].image
	image := request.spec.containers[i].image
	not inSidecarContainerList(image)

	value = request.spec.containers[i].image
	operator_contains_any(user_provided_data, value)
}

violationmsgs[msg]{
	request := _get_input("get")

	criteria_0(request)    # check [item.spec.initContainers[_].lifecycle.postStart.tcpSocket.host] with [containsAll]
	msg:="criteria_0 met. (check [item.spec.initContainers[_].lifecycle.postStart.tcpSocket.host] with [containsAll] op)"
}

violationmsgs[msg]{
	request := _get_input("get")

	not criteria_0(request)    # check [item.spec.initContainers[_].lifecycle.postStart.tcpSocket.host] with [containsAll]
	msg:="criteria_0 not met. (check [item.spec.initContainers[_].lifecycle.postStart.tcpSocket.host] with [containsAll] op)"
}

violationmsgs[msg]{
	request := _get_input("get")

	criteria_1(request)    # check [item.spec.containers[_].image] with [containsAny]
	msg:="criteria_1 met. (check [item.spec.containers[_].image] with [containsAny] op)"
}

violationmsgs[msg]{
	request := _get_input("get")

	not criteria_1(request)    # check [item.spec.containers[_].image] with [containsAny]
	msg:="criteria_1 not met. (check [item.spec.containers[_].image] with [containsAny] op)"
}

rawInput[msg]{
	1==2
	msg := input
}

# type-1: for regular workload, get it's spec.template
_get_input(w) := x {
	w == "get"

	supportedKind = ["Deployment", "DaemonSet", "Job", "ReplicaSet", "ReplicationController", "StatefulSet"]
	input.request.kind.kind == supportedKind[_]

    input.request.object.spec.template
    x := input.request.object.spec.template
}

# type-2: for cronjob workload, the format is different from major workload
_get_input(w) := x {
	w == "get"

	supportedKind = ["CronJob"]
	input.request.kind.kind == supportedKind[_]

	input.request.object.spec.jobTemplate.spec.template
    x :=  input.request.object.spec.jobTemplate.spec.template
}

# type-3: for pod workload, the format is different from major workload
# We cannot use the [input.request.object] here because this will also generate output as [input.request.object.spec.template]
# this cause Rego runtime error
# 	"message": "functions must not produce multiple outputs for same inputs",
# need to add addition helper to check like kind==Pod
_get_input(w) := x {
	w == "get"
	input.request.kind.kind == "Pod"
	input.request.object
   x :=  input.request.object
}

# type-1a: [for testing in Rego Playground], same as type-1. comment out the false statement (1==2) for testing.
_get_input(w) := x {
	1==2

	w == "get"

	supportedKind = ["Deployment", "DaemonSet", "Job", "ReplicaSet", "ReplicationController", "StatefulSet"]
	input.input.request.kind.kind == supportedKind[_]

    input.input.request.object.spec.template		# used in Rego Playground (add prefix input)
    x := input.input.request.object.spec.template
}

# type-2a: [for testing in Rego Playground], same as type-2. comment out the false statement (1==2) for testing.
_get_input(w) := x {
	1==2

	w == "get"

	supportedKind = ["CronJob"]
	input.input.request.kind.kind == supportedKind[_]

	input.input.request.object.spec.jobTemplate.spec.template
    x := input.input.request.object.spec.jobTemplate.spec.template
}

# type-3a: [for testing in Rego Playground], same as type-3. comment out the false statement (1==2) for testing.
_get_input(w) := x {
	1==2

	w == "get"
	input.input.request.kind.kind == "Pod"
	input.input.request.object
    x := input.input.request.object
}

_get_namespace(w) := x{
	w == "get"
	x := input.request.namespace
}

_get_namespace(w) := x{
	w == "get"
	not input.request.namespace
    x := "default"
}

getSubjects(binding):=subjects
{
	subjects := binding.request.object.subjects		# for data generated by admission review
}

getSubjects(binding):=subjects
{
	subjects := binding.subjects		# for data generated by xlate2()
}

getRoleRef(binding):=rolRef
{
    rolRef := binding.request.object.roleRef		# for data generated by admission review
}

getRoleRef(binding):=rolRef
{
    rolRef := binding.roleRef		# for data generated by xlate2()
}

## operator -- contains all (array)
operator_contains_all(criteria_values, items){
	is_array(items)
	matched := [name | regex.match(criteria_values[j], items[i]); name = items[i]]
	count(matched) == count(criteria_values)
}

## operator -- contains all (single value)
operator_contains_all(criteria_values, item){
    is_string(item)
    uniq_items := { x | x = criteria_values[_]}
    count(uniq_items)==1
    check_contains(criteria_values, item)
}

## operator -- contains any (array)
operator_contains_any(criteria_values, items){
	is_array(items)
	matched := [name | regex.match(criteria_values[j], items[i]); name = items[i]]
	count(matched)>=1
}

## operator -- contains any (single value)
operator_contains_any(criteria_values, item){
	is_string(item)
	check_contains(criteria_values, item)
}

## operator -- not contains any (array)
operator_not_contains_any(criteria_values, items){
	is_array(items)
	matched := [name | regex.match(criteria_values[j], items[i]); name = items[i]]
	count(matched)==0
}

## operator -- not contains any (single value)
operator_not_contains_any(criteria_values, item){
	is_string(item)
	not check_contains(criteria_values, item)
}

## operator -- contains other than  (array)
operator_contains_other_than(criteria_values, items){
	is_array(items)
	matched := [name | regex.match(criteria_values[j], items[i]); name = items[i]]
	count(items) != count(matched)
}

## operator -- contains other than (single value)
operator_contains_other_than(criteria_values, item){
	is_string(item)
	not check_contains(criteria_values, item)
}

has_key(x, k) { _ = x[k] }

check_contains(patterns, value) {
    regex.match(patterns[_], value)
}

inSidecarContainerList(image){
	sidecarImages := ["docker.io/istio/proxyv2","https://docker.io/istio/proxyv2",
						"linkerd-io/proxy","https://gcr.io/linkerd-io/proxy",
						"istio-release/proxyv2", "https://gcr.io/istio-release/proxyv2"]
    startswith(image, sidecarImages[_])
}else = false{
	true
}

get_serviceAccountName(request) := sa {
    not has_key(request.spec, "serviceAccountName")
    sa = "default"
}

get_serviceAccountName(request) := sa {
    has_key(request.spec, "serviceAccountName")
    sa = request.spec.serviceAccountName
}


