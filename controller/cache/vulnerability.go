package cache

import (
	"context"
	"encoding/json"
	"errors"
	"sync"

	log "github.com/sirupsen/logrus"

	"github.com/neuvector/neuvector/controller/access"
	"github.com/neuvector/neuvector/controller/api"
	"github.com/neuvector/neuvector/controller/common"
	"github.com/neuvector/neuvector/share"
	"github.com/neuvector/neuvector/share/cluster"
	scanUtils "github.com/neuvector/neuvector/share/scan"
)

type vpCache struct {
	profile      *share.CLUSVulnerabilityProfile
	rp           *api.RESTVulnerabilityProfile
	intf         scanUtils.VPFInterface
	updateCtx    context.Context
	updateCancel context.CancelFunc
}

var vpCacheMap map[string]*vpCache = make(map[string]*vpCache)
var vpMutex sync.RWMutex

func vulnerabilityProfile2REST(cvp *share.CLUSVulnerabilityProfile) *api.RESTVulnerabilityProfile {
	rvp := api.RESTVulnerabilityProfile{
		Name:    cvp.Name,
		Entries: make([]api.RESTVulnerabilityProfileEntry, len(cvp.Entries)),
		CfgType: cfgTypeMapping[cvp.CfgType],
	}

	i := 0
	for _, ce := range cvp.Entries {
		rvp.Entries[i] = api.RESTVulnerabilityProfileEntry{
			ID:      ce.ID,
			Name:    ce.Name,
			Comment: ce.Comment,
			Days:    ce.Days,
			Domains: ce.Domains,
			Images:  ce.Images,
		}
		i++
	}

	return &rvp
}

func vulnerabilityConfigUpdate(nType cluster.ClusterNotifyType, key string, value []byte) {
	log.WithFields(log.Fields{"type": cluster.ClusterNotifyName[nType], "key": key}).Debug()

	if share.CLUSVulnerabilityKey2Type(key) != "profile" {
		return
	}

	name := share.CLUSVulnerabilityProfileKey2Name(key)

	switch nType {
	case cluster.ClusterNotifyAdd, cluster.ClusterNotifyModify:
		var cvp share.CLUSVulnerabilityProfile
		if err := json.Unmarshal(value, &cvp); err != nil {
			log.WithFields(log.Fields{"err": err}).Debug("Fail to decode")
			return
		}

		cache := &vpCache{
			profile: &cvp,
			rp:      vulnerabilityProfile2REST(&cvp),
		}
		cache.intf = scanUtils.MakeVulnerabilityProfileFilter(cache.rp)

		vpMutex.Lock()
		if c, ok := vpCacheMap[name]; ok {
			if c.updateCtx != nil && !errors.Is(c.updateCtx.Err(), context.Canceled) {
				c.updateCancel()
			}
		}
		vpCacheMap[name] = cache
		vpMutex.Unlock()

		vulProfUpdateTimer.Reset(vulProfUpdateDelayIdle)
	case cluster.ClusterNotifyDelete:
		vpMutex.Lock()
		if c, ok := vpCacheMap[name]; ok {
			if c.updateCtx != nil && !errors.Is(c.updateCtx.Err(), context.Canceled) {
				c.updateCancel()
			}
			delete(vpCacheMap, name)
		}
		vpMutex.Unlock()

		vulProfUpdateTimer.Reset(vulProfUpdateDelayIdle)
	}
}

func (m CacheMethod) GetVulnerabilityProfileInterface(name string) scanUtils.VPFInterface {
	vpMutex.RLock()
	defer vpMutex.RUnlock()
	if cache, ok := vpCacheMap[name]; !ok {
		log.WithFields(log.Fields{"profile": share.DefaultVulnerabilityProfileName}).Error("Vulnerability profile not found")
		return scanUtils.MakeVulnerabilityProfileFilter(nil)
	} else {
		return cache.intf
	}
}

func (m CacheMethod) GetVulnerabilityProfile(name string, acc *access.AccessControl) (*api.RESTVulnerabilityProfile, error) {
	vpMutex.RLock()
	defer vpMutex.RUnlock()
	if cache, ok := vpCacheMap[name]; ok {
		if !acc.Authorize(cache.profile, nil) {
			return nil, common.ErrObjectAccessDenied
		}
		return cache.rp, nil
	}
	return nil, common.ErrObjectNotFound
}

func (m CacheMethod) GetAllVulnerabilityProfiles(acc *access.AccessControl) []*api.RESTVulnerabilityProfile {
	list := make([]*api.RESTVulnerabilityProfile, 0)

	vpMutex.RLock()
	defer vpMutex.RUnlock()
	for _, cache := range vpCacheMap {
		if !acc.Authorize(cache.profile, nil) {
			continue
		}
		list = append(list, cache.rp)
	}
	return list
}
