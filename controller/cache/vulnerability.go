package cache

import (
	"context"
	"encoding/json"
	"errors"
	"sync"

	log "github.com/sirupsen/logrus"

	"github.com/neuvector/neuvector/controller/access"
	"github.com/neuvector/neuvector/controller/api"
	"github.com/neuvector/neuvector/controller/common"
	"github.com/neuvector/neuvector/share"
	"github.com/neuvector/neuvector/share/cluster"
	scanUtils "github.com/neuvector/neuvector/share/scan"
)

type vpCache struct {
	profile      *share.CLUSVulnerabilityProfile
	rp           *api.RESTVulnerabilityProfile
	intf         scanUtils.VPFInterface
	updateCtx    context.Context
	updateCancel context.CancelFunc
}

var vpSettings share.CLUSVulProfileSettings = share.CLUSVulProfileSettings{ActiveProfile: share.DefaultVulnerabilityProfileName, CfgType: share.UserCreated}
var vpCacheMap map[string]*vpCache = make(map[string]*vpCache)
var vpMutex sync.RWMutex

func vulnerabilityProfile2REST(cvp *share.CLUSVulnerabilityProfile) *api.RESTVulnerabilityProfile {
	rvp := api.RESTVulnerabilityProfile{
		Name:    cvp.Name,
		Entries: make([]api.RESTVulnerabilityProfileEntry, len(cvp.Entries)),
		CfgType: cfgTypeMapping[cvp.CfgType],
	}

	i := 0
	for _, ce := range cvp.Entries {
		rvp.Entries[i] = api.RESTVulnerabilityProfileEntry{
			ID:      ce.ID,
			Name:    ce.Name,
			Comment: ce.Comment,
			Days:    ce.Days,
			Domains: ce.Domains,
			Images:  ce.Images,
		}
		i++
	}

	return &rvp
}

func vulnerabilityConfigUpdate(nType cluster.ClusterNotifyType, key string, value []byte) {
	log.WithFields(log.Fields{"type": cluster.ClusterNotifyName[nType], "key": key}).Debug()

	if share.CLUSVulnerabilityKey2Type(key) != "profile" {
		return
	}

	name := share.CLUSVulnerabilityProfileKey2Name(key)

	switch nType {
	case cluster.ClusterNotifyAdd, cluster.ClusterNotifyModify:
		if name == "" {
			var settings share.CLUSVulProfileSettings
			if err := json.Unmarshal(value, &settings); err != nil {
				log.WithFields(log.Fields{"err": err}).Debug("Fail to decode")
				return
			}
			vpSettings = settings
		} else {
			var cvp share.CLUSVulnerabilityProfile
			if err := json.Unmarshal(value, &cvp); err != nil {
				log.WithFields(log.Fields{"err": err}).Debug("Fail to decode")
				return
			}

			cache := &vpCache{
				profile: &cvp,
				rp:      vulnerabilityProfile2REST(&cvp),
			}
			cache.intf = scanUtils.MakeVulnerabilityProfileFilter(cache.rp)

			vpMutex.Lock()
			if c, ok := vpCacheMap[name]; ok {
				if c.updateCtx != nil && !errors.Is(c.updateCtx.Err(), context.Canceled) {
					c.updateCancel()
				}
			}
			vpCacheMap[name] = cache
			vpMutex.Unlock()

			vulProfUpdateTimer.Reset(vulProfUpdateDelayIdle)
		}
	case cluster.ClusterNotifyDelete:
		if name == "" {
			vpSettings = share.CLUSVulProfileSettings{
				ActiveProfile: share.DefaultVulnerabilityProfileName,
				CfgType:       share.UserCreated,
			}
		} else {
			vpMutex.Lock()
			if c, ok := vpCacheMap[name]; ok {
				if c.updateCtx != nil && !errors.Is(c.updateCtx.Err(), context.Canceled) {
					c.updateCancel()
				}
				delete(vpCacheMap, name)
			}
			vpMutex.Unlock()

			vulProfUpdateTimer.Reset(vulProfUpdateDelayIdle)
		}
	}
}

func (m CacheMethod) GetVulnerabilityProfileInterface(name string) scanUtils.VPFInterface {
	vpMutex.RLock()
	defer vpMutex.RUnlock()
	if cache, ok := vpCacheMap[name]; !ok {
		log.WithFields(log.Fields{"profile": share.DefaultVulnerabilityProfileName}).Error("Vulnerability profile not found")
		return scanUtils.MakeVulnerabilityProfileFilter(nil)
	} else {
		return cache.intf
	}
}

func (m CacheMethod) GetVulnerabilityProfile(name string, acc *access.AccessControl) (*api.RESTVulnerabilityProfile, error) {
	vpMutex.RLock()
	defer vpMutex.RUnlock()
	if cache, ok := vpCacheMap[name]; ok {
		if !acc.Authorize(cache.profile, nil) {
			return nil, common.ErrObjectAccessDenied
		}
		return cache.rp, nil
	}
	return nil, common.ErrObjectNotFound
}

func (m CacheMethod) GetAllVulnerabilityProfiles(acc *access.AccessControl) (api.RESTVulProfileSettings, []*api.RESTVulnerabilityProfile) {
	list := make([]*api.RESTVulnerabilityProfile, 0)

	settings := api.RESTVulProfileSettings{
		ActiveProfile: vpSettings.ActiveProfile,
		CfgType:       cfgTypeMapping[vpSettings.CfgType],
	}

	vpMutex.RLock()
	defer vpMutex.RUnlock()
	for _, cache := range vpCacheMap {
		if !acc.Authorize(cache.profile, nil) {
			continue
		}
		list = append(list, cache.rp)
	}
	return settings, list
}
